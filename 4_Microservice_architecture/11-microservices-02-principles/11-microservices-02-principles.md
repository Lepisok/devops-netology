
# Домашнее задание к занятию "11.02 Микросервисы: принципы"

Вы работаете в крупной компанию, которая строит систему на основе микросервисной архитектуры.
Вам как DevOps специалисту необходимо выдвинуть предложение по организации инфраструктуры, для разработки и эксплуатации.

## Задача 1: API Gateway 

Предложите решение для обеспечения реализации API Gateway. Составьте сравнительную таблицу возможностей различных программных решений. На основе таблицы сделайте выбор решения.

Решение должно соответствовать следующим требованиям:
- Маршрутизация запросов к нужному сервису на основе конфигурации
- Возможность проверки аутентификационной информации в запросах
- Обеспечение терминации HTTPS

Обоснуйте свой выбор.  

Решение:  
| Решения                      |        HTTPS        |         AUTH         |    Routing        |
|------------------------------|:-------------------:|:--------------------:|------------------:|
| Tyk API Gateway              |          +          |           +          |         +         |
| Janus                        |          +          |           +          |         +         |
| Amazon API Gateway           |          +          |           +          |         +         |
| Nginx API Gateway            |          +          |           +          |         +         |
| Gravitee API Gateway         |          +          |           +          |         +         |

Полезные ссылки:  
1) https://github.com/TykTechnologies/tyk (Tyk API Gateway)  
2) https://github.com/motiv-labs/janus    (Janus)  
3) https://aws.amazon.com/ru/api-gateway/ (Amazon API Gateway)  
4) https://www.nginx.com/blog/deploying-nginx-plus-as-an-api-gateway-part-1/ (Nginx API Gateway)  
5) https://docs.gravitee.io/apim/1.x/apim_installguide_gateway_configuration.html (Gravitee API Gateway)  
Решение:  Для начала я бы выбрал Nginx API Gateway, так как уже был опыт настройки и решение бесплатное. Далее с ростом архитектуры, начал бы изучать документацию из предоставленных решений. После тестирования всех решений, выбрал наиболее подходящее. Пока из прочитанных возможностей отдаю предпочтение Gravitee API Gateway.  
## Задача 2: Брокер сообщений

Составьте таблицу возможностей различных брокеров сообщений. На основе таблицы сделайте обоснованный выбор решения.

Решение должно соответствовать следующим требованиям:
- Поддержка кластеризации для обеспечения надежности
- Хранение сообщений на диске в процессе доставки
- Высокая скорость работы
- Поддержка различных форматов сообщений
- Разделение прав доступа к различным потокам сообщений
- Простота эксплуатации

Обоснуйте свой выбор.  

Решение:  
| Решения                      |Кластеризация|Хранение|Скорость|Форматы сообщений|Разделение прав|Простота|
|------------------------------|:-----------:|:------:|:------:|:---------------:|:-------------:|:------:|
| RabbitMQ                     |      +      |    +   |    +   |       +         |       +       |    -   |
| Kafka                        |      +      |    +   |    +   |       -         |       +       |    +   |
| AWS SNS/SQS                  |      +      |    +   |    +   |       +         |       +       |    -   |

Решение:  
## RabbitMQ   
Плюсы RabbitMQ  
1) Лёгкость разработки. У RabbitMQ есть библиотеки клиента для большинства современных языков и открытый исходный код, чтобы в нём разбираться.  

2) Простое администрирование. У RabbitMQ удобная админка, где вы можете в режиме реального времени разбираться с тем, что происходит. 3) Роутинги можно настраивать в процессе, переключая нагрузку и меняя правила обработки.  

4) Тонкая настройка. Многие параметры можно менять, чтобы подстроить систему под свои нужды. Особенно это касается очередей.  

Минусы RabbitMQ  
1) Работа при высокой нагрузке. У RabbitMQ есть сложности при горизонтальном масштабировании в кластере. Приходится добавлять настройки кластеризации над очередями, а они сложные и работают плохо. Приходится выбирать, чем пожертвовать — гибкостью или скоростью.  

## В каких случаях использовать RabbitMQ
Когда важна гибкость маршрутизации сообщений внутри системы. В таком случае он предоставляет инструменты для построения путей доставки данных и способен решить самые хитрые сценарии в организации потоков событий. 

Если вам важен сам факт доставки сообщений и порядок их получения.  

## Kafka  
Плюсы Kafka  
1) Делает всего две вещи: записывает и отдаёт. Если использовать брокер вместе с надкластером ZooKeeper, то можно наладить кластерные трансферы — Kafka долго этого не умел. 

2) Пропускная способность — миллионы сообщений в секунду. Причём её можно эффективно наращивать: добавить датчик в кластер и при переполнении просто создавать новый, настраивая между ними репликацию. Именно поэтому Kafka стал промышленным стандартом.

3) Позволяет перечитывать сообщения. Если мы прочитали сообщение, а потом потеряли изменение в базе, можно откатить офсет назад и прочитать сообщение снова. 

4) Позволяет читать сообщения пачками. Можно запросить сразу 1000 сообщений, что снижает нагрузку на сеть.

Минусы Kafka
1) Проблемы с обработкой битых сообщений. В RabbitMQ необработанное сообщение мы заново закидываем в очередь, и оно крутится, пока его не получится обработать. В Kafka для обработки следующего сообщения нам нужно обработать его или пропустить текущее. Битое мы просто потеряем навсегда.

2) В Kafka для этого применяют концепцию dead letter queue — отдельного места для сохранения битых сообщений. Мы берём что-то битое, кладём отдельно и потом пытаемся обработать снова. Но это всё равно дополнительная сложность.

3) Нужно вести учёт последнего прочитанного сообщения, причём для каждого читателя. Потому что данные неизменны, и мы раскидываем не их, а читателей по одному и тому же массиву данных. То есть храним те точки, где они остановились в чтении. Для этого есть несколько решений, но все они, конечно, утяжеляют систему.

## Когда использовать Kafka
При конвейерной обработке данных. Kafka хорошо работает как общая шина для нескольких сервисов. Сервис что-то сделал, записал результат, следующий по конвейеру считал — записал, и так далее. В RabbitMQ это сработает хуже, так как конвейерность может нарушиться.

При Event-driven architecture. В этом случае сообщения можно бродкастить всем необходимым сервисам, и нужные адресаты их получат. В RabbitMQ обязательно нужно знать, сколько у вас получателей. Особенно это актуально в микросервисном мире, где количество реплик сервиса меняется динамически.

При использовании буфера для логов и метрик. Промежуточное хранилище для большого количества данных, где они будут сохранны и упорядочены.  

## SQS  
Плюсы SQS  
1) Популярность за рубежом. Практически все крупные компании используют инфраструктуру Amazon, поэтому и этот брокер актуален. Если вы ищете работу за рубежом, то знание сервисов Amazon будет большим плюсом.

2) Безопасность. Тщательное шифрование всех сообщений, которые идут в брокера и от брокера.

3) Автоматические бэкапы.

4) Простая прямая отправка имейлов, СМС, http-запросов.

5) Встроенный DLQ. Битые сообщения можно хранить и обрабатывать позже.

6) Интеграция со всеми другими сервисами Amazon. У него тот же тип авторизации, понятная структура, дизайн и SDK.

Минусы SQS  
1) Vendor lock. Полная зависимость от Amazon. Перейти на другого поставщика, если что-то случится, будет сложно.

## Когда применять SQS  
Если вы уже работаете с продуктами экосистемы Amazon и вам нужен брокер сообщений.

Если вы хотите выстроить единую экосистему и выбираете для этого Amazon.

Если вам нужно стабильное и готовое к работе решение.  

Опять же всё зависит от инфраструктуры. Для не большого сервиса, который в будущем особо не будет разрастаться лучше выбрать RabbitMQ, но если сервис будет разрасаться, то лучше выбрать Kafka  

## Задача 3: API Gateway * (необязательная)

### Есть три сервиса:

**minio**
- Хранит загруженные файлы в бакете images
- S3 протокол

**uploader**
- Принимает файл, если он картинка сжимает и загружает его в minio
- POST /v1/upload

**security**
- Регистрация пользователя POST /v1/user
- Получение информации о пользователе GET /v1/user
- Логин пользователя POST /v1/token
- Проверка токена GET /v1/token/validation

### Необходимо воспользоваться любым балансировщиком и сделать API Gateway:

**POST /v1/register**
- Анонимный доступ.
- Запрос направляется в сервис security POST /v1/user

**POST /v1/token**
- Анонимный доступ.
- Запрос направляется в сервис security POST /v1/token

**GET /v1/user**
- Проверка токена. Токен ожидается в заголовке Authorization. Токен проверяется через вызов сервиса security GET /v1/token/validation/
- Запрос направляется в сервис security GET /v1/user

**POST /v1/upload**
- Проверка токена. Токен ожидается в заголовке Authorization. Токен проверяется через вызов сервиса security GET /v1/token/validation/
- Запрос направляется в сервис uploader POST /v1/upload

**GET /v1/user/{image}**
- Проверка токена. Токен ожидается в заголовке Authorization. Токен проверяется через вызов сервиса security GET /v1/token/validation/
- Запрос направляется в сервис minio  GET /images/{image}

### Ожидаемый результат

Результатом выполнения задачи должен быть docker compose файл запустив который можно локально выполнить следующие команды с успешным результатом.
Предполагается что для реализации API Gateway будет написан конфиг для NGinx или другого балансировщика нагрузки который будет запущен как сервис через docker-compose и будет обеспечивать балансировку и проверку аутентификации входящих запросов.
Авторизаци
curl -X POST -H 'Content-Type: application/json' -d '{"login":"bob", "password":"qwe123"}' http://localhost/token

**Загрузка файла**

curl -X POST -H 'Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJib2IifQ.hiMVLmssoTsy1MqbmIoviDeFPvo-nCd92d4UFiN2O2I' -H 'Content-Type: octet/stream' --data-binary @yourfilename.jpg http://localhost/upload

**Получение файла**
curl -X GET http://localhost/images/4e6df220-295e-4231-82bc-45e4b1484430.jpg

---

#### [Дополнительные материалы: как запускать, как тестировать, как проверить](https://github.com/netology-code/devkub-homeworks/tree/main/11-microservices-02-principles)

---

### Как оформить ДЗ?

Выполненное домашнее задание пришлите ссылкой на .md-файл в вашем репозитории.

---


